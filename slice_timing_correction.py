# -*- coding: utf-8 -*-
"""Slice_timing_correction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e9b-CqDevXPCk8e6NolB2ZxnegYzJN2d
"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)
import numpy as np
import nibabel as nib
import matplotlib.pyplot as plt

# Load the NIfTI image
input_image = "/content/drive/My Drive/Datasets/nifti/data.nii.gz"  # Replace with your NIfTI image file path
nifti_img = nib.load(input_image)

# Get the image data and header
data = nifti_img.get_fdata()
affine = nifti_img.affine
print(data.shape)
# Calculate the number of slices
num_slices = data.shape[2]

def slice_timing_correction(data,num_slices,affine,TR, slice_timing):
    # Initialize array for slice timing corrected data
    slice_timing_corrected_data = np.zeros_like(data)
    # Loop through each volume in the time series
    for i in range(data.shape[-1]):
        # Loop through each slice
        for j in range(num_slices):
            # Calculate slice timing correction
            shift_amount = int(round((slice_timing[j] / TR) * data.shape[-1]))

            # Apply slice timing correction
            slice_timing_corrected_data[:, :, j, i] = np.roll(data[:, :, j, i], shift_amount, axis=-1)

    # Create a new NIfTI image with slice timing corrected data
    slice_timing_corrected_img = nib.Nifti1Image(slice_timing_corrected_data, affine)

    return slice_timing_corrected_img

# Call slice_timing_correction function with example parameters
TR = 2.0  # Example repetition time in seconds
# Generate slice timing values assuming sequential acquisition
slice_timing = [i * (TR / num_slices) for i in range(num_slices)]
# Perform slice timing correction
slice_timing_corrected_img = slice_timing_correction(data,num_slices,affine, TR, slice_timing)

# Plot the results
# Adjust figure size and DPI
fig, axes = plt.subplots(1, 2, figsize=(10, 5), dpi=80)

# Original Mean Image
original_mean_img = np.rot90(np.mean(nib.load(input_image).get_fdata(), axis=-1))
axes[0].imshow(original_mean_img[:, :, original_mean_img.shape[-1] // 2], cmap='gray',interpolation='bilinear')
axes[0].set_title('Original Mean Image')
axes[0].axis('off')

# Slice Timing Corrected Mean Image
slice_timing_corrected_mean_img = np.rot90(np.mean(slice_timing_corrected_img.get_fdata(), axis=-1))
axes[1].imshow(slice_timing_corrected_mean_img[:, :, slice_timing_corrected_mean_img.shape[-1] // 2], cmap='gray',interpolation='bilinear')
axes[1].set_title('Slice Timing Corrected Mean Image')
axes[1].axis('off')

plt.tight_layout()
plt.show()